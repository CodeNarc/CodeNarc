CodeNarc Report: Sample Project - Aug 29, 2021 2:00:51 PM

Summary: TotalFiles=416 FilesWithViolations=57 P1=0 P2=76 P3=36

File: AbstractAstVisitorRuleTest.groovy
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=184 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.doNotApplyToClassNames = 'Xxx'        // doNotApply = NO]
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=187 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.applyToClassNames = 'Xxx'             // apply = NO]
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=188 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.doNotApplyToClassNames = 'Xxx'        // doNotApply = NO]

File: AbstractEnhanceableAstVisitorRuleTest.groovy
    Violation: Rule=MisorderedStaticImports P=3 Line=22 Msg=[Static imports should appear before normal imports] Src=[import static org.codenarc.rule.AbstractEnhanceableAstVisitorRule.ENHANCED_MODE_SYSTEM_PROPERTY]
    Violation: Rule=MisorderedStaticImports P=3 Line=23 Msg=[Static imports should appear before normal imports] Src=[import static org.codenarc.source.SourceCode.DEFAULT_COMPILER_PHASE]

File: AbstractRuleTest.groovy
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=137 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.doNotApplyToFilesMatching = NO_MATCH    // doNotApply = NO]
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=140 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.applyToFilesMatching = NO_MATCH         // apply = NO]
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=141 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.doNotApplyToFilesMatching = NO_MATCH    // doNotApply = NO]
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=177 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.applyToFileNames = 'org/codenarc/MyOtherTest.groovy']
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=225 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.doNotApplyToFileNames = 'Xxx.groovy'    // doNotApply = NO]
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=228 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.applyToFileNames = 'Xxx.groovy'         // apply = NO]
    Violation: Rule=UnnecessaryObjectReferences P=3 Line=229 Msg=[The code could be more concise by using a with() or identity() block] Src=[rule.doNotApplyToFileNames = 'Xxx.groovy'    // doNotApply = NO]

File: InlineViolationsParserTest.groovy
    Violation: Rule=MisorderedStaticImports P=3 Line=20 Msg=[Static imports should appear before normal imports] Src=[import static org.codenarc.rule.InlineViolationsParser.inlineViolation]
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=199 Msg=[The return keyword is not needed and can be removed] Src=[return [lineNumber: lineNumber, sourceLineText: sourceLineText, messageText: messageText]]

File: comments/AbstractJavadocEmptyTagRuleTestCase.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=53 Msg=[The return keyword is not needed and can be removed] Src=[return rule.name]
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=56 Msg=[The return keyword is not needed and can be removed] Src=[return "The javadoc ${getTag()} tag is empty"]

File: comments/AbstractJavadocMissingDescriptionRuleTestCase.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=51 Msg=[The return keyword is not needed and can be removed] Src=[return rule.name]
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=54 Msg=[The return keyword is not needed and can be removed] Src=[return "The description for the javadoc ${getTag()} tag is missing"]

File: comments/JavadocEmptyAuthorTagRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@author']

File: comments/JavadocEmptyExceptionTagRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@exception']

File: comments/JavadocEmptyParamTagRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@param']

File: comments/JavadocEmptyReturnTagRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@return']

File: comments/JavadocEmptySeeTagRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@see']

File: comments/JavadocEmptySinceTagRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@since']

File: comments/JavadocEmptyThrowsTagRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@throws']

File: comments/JavadocEmptyVersionTagRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@version']

File: comments/JavadocMissingExceptionDescriptionRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@exception']

File: comments/JavadocMissingParamDescriptionRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@param']

File: comments/JavadocMissingThrowsDescriptionRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=27 Msg=[The return keyword is not needed and can be removed] Src=[return '@throws']

File: convention/CompileStaticRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=34 Msg=[The return keyword is not needed and can be removed] Src=[return new CompileStaticRule()]

File: design/NestedForLoopRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=106 Msg=[The return keyword is not needed and can be removed] Src=[return inlineViolation('Nested for loop')]

File: design/OptionalCollectionReturnTypeRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=128 Msg=[The return keyword is not needed and can be removed] Src=[return "The method $methodName in class MyClass returns an Optional collection"]

File: design/PrivateFieldCouldBeFinalRuleTest.groovy
    Violation: Rule=MethodCount P=2 Line=26 Msg=[Class org.codenarc.rule.design.PrivateFieldCouldBeFinalRuleTest has 34 methods] Src=[class PrivateFieldCouldBeFinalRuleTest extends AbstractRuleTestCase<PrivateFieldCouldBeFinalRule> {]

File: formatting/BracesForForLoopRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=101 Msg=[The String '
            for(String name=${SomeClass.SOME_CONSTANT}; name==null;)  // And what about {}
            {
                doStuff()
            }
        ' contains a GString-type expression: '${SomeClass.SOME_CONSTANT}; name==null;)  // And what about {}'] Src=[final SOURCE = ''']

File: formatting/BracesForIfElseRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=59 Msg=[The String '
            if (someContainer."${SomeClass.SOME_CONSTANT}" != null)  // And what about {}
            {
                doStuff()
            }
        ' contains a GString-type expression: '${SomeClass.SOME_CONSTANT}" != null)  // And what about {}'] Src=[final SOURCE = ''']

File: formatting/BracesForMethodRuleTest.groovy
    Violation: Rule=MethodCount P=2 Line=28 Msg=[Class org.codenarc.rule.formatting.BracesForMethodRuleTest has 38 methods] Src=[class BracesForMethodRuleTest extends AbstractRuleTestCase<BracesForMethodRule> {]
    Violation: Rule=GStringExpressionWithinString P=2 Line=356 Msg=[The String '
            class MyClass {
                int size(String name = "${SomeClass.SOME_CONSTANT}")
                {
                    return 99
                }
            }
        ' contains a GString-type expression: '${SomeClass.SOME_CONSTANT}'] Src=[final SOURCE = ''']

File: formatting/ClassEndsWithBlankLineRuleTest.groovy
    Violation: Rule=MethodCount P=2 Line=27 Msg=[Class org.codenarc.rule.formatting.ClassEndsWithBlankLineRuleTest has 33 methods] Src=[class ClassEndsWithBlankLineRuleTest extends AbstractRuleTestCase<ClassEndsWithBlankLineRule> {]

File: formatting/ClassStartsWithBlankLineRuleTest.groovy
    Violation: Rule=MethodCount P=2 Line=27 Msg=[Class org.codenarc.rule.formatting.ClassStartsWithBlankLineRuleTest has 45 methods] Src=[class ClassStartsWithBlankLineRuleTest extends AbstractRuleTestCase<ClassStartsWithBlankLineRule> {]

File: formatting/IndentationRuleTest.groovy
    Violation: Rule=MethodCount P=2 Line=27 Msg=[Class org.codenarc.rule.formatting.IndentationRuleTest has 53 methods] Src=[class IndentationRuleTest extends AbstractRuleTestCase<IndentationRule> {]
    Violation: Rule=GStringExpressionWithinString P=2 Line=607 Msg=[The String '
            |class MyClass {
            |    private void execute() {
            |        try {
            |            executeWithArgs(args)
            |        }
            |        catch(Throwable t) {
            |            println "ERROR: ${t.message}"
            |            t.printStackTrace()
            |        }
            |        finally {
            |            closeResources()
            |        }
            |    }
            |    private void executeOtherOne() {
            |        try {
            |            executeWithArgs(args)
            |        } catch(Throwable t) {
            |            t.printStackTrace()
            |        } finally {
            |            closeResources()
            |        }
            |    }
            |}
        ' contains a GString-type expression: '${t.message}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=897 Msg=[The String '
            |project.files(project.configurations.scaconfig.files.findAll { File it -> it.name.endsWith '.aar' }.collect { File it ->
            |    MessageDigest sha1 = MessageDigest.getInstance('SHA1')
            |    String inputFile = 'COMMAND=PREPARE_LIBRARY\n' +
            |        "FILE_PATH=${it.absolutePath}\n"
            |    String hash = new BigInteger(1, sha1.digest(inputFile.bytes)).toString(16)
            |    cacheDir + hash + File.separator + 'output/jars/classes.jar'
            |}).asFileTree
        ' contains a GString-type expression: '${it.absolutePath}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=911 Msg=[The String '
            |"${if (true) 'content' else ''}"
        ' contains a GString-type expression: '${if (true) 'content' else ''}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=919 Msg=[The String '
            |package com.sample
            |
            |trait RegressionTest {
            |
            |    String callStackPath = "src/test/resources/callstacks/"
            |
            |   /**
            |     * Checks the current callstack is the same as the reference callstack.
            |     * The reference callstack can be updated into a txt file in the callStackPath
            |     *
            |     * Pattern: <RegressionTest.callStackPath>/<ClassTestSimpleName><_subname>.txt
            |     * @param subname optional subname, used in the reference callstack filename
            |     */
            |    void testNonRegression(String subname = '') {
            |        String targetFileName = "${callStackPath}${this.class.simpleName}"
            |        if (subname) {
            |            targetFileName += "_${subname}"
            |        }
            |        RegressionTestHelper.testNonRegression(helper, targetFileName)
            |    }
            |}
        ' contains a GString-type expression: '${callStackPath}${this.class.simpleName}'] Src=[final SOURCE = ''']
    Violation: Rule=ClassSize P=3 Line=27 Msg=[Class "IndentationRuleTest" is 1052 lines]

File: formatting/IndentationRule_MethodChainingTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=82 Msg=[The String '
            |buildFileList()
            |    .collect { File it ->
            |        MessageDigest sha1 = MessageDigest.getInstance('SHA1')
            |        String inputFile = 'COMMAND=PREPARE_LIBRARY\n' +
            |            "FILE_PATH=${it.absolutePath}\n"
            |        cacheDir + File.separator + inputFile + sha1
            |    }
            |    .each { name ->
            |        println name
            |    }
            |println "done"
            |
            |list2.collect { item ->
            |    item.name
            |}.each { name -> println name }
            |
            |otherList.collect { item -> item.name }.each { name -> println name }
            |
            |if (expr instanceof ConstructorCallExpression || expr instanceof CastExpression) {
            |    [Map, Iterable, List, Collection, ArrayList, Set, HashSet].findAll {
            |        AstUtil.classNodeImplementsType(expr.type, it)
            |    }.each {
            |        callbackFunction()
            |    }
            |}
        ' contains a GString-type expression: '${it.absolutePath}'] Src=[final SOURCE = ''']

File: formatting/MissingBlankLineBeforeAnnotatedFieldRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=98 Msg=[The String '
            class MyClass {
                private @Autowired DataSource dataSource
                private @Value('${name}') String name
            }
        ' contains a GString-type expression: '${name}'] Src=[final SOURCE = ''']

File: formatting/SpaceAfterClosingBraceRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=38 Msg=[The String '
            class MyClass {
                def myMethod() {
                    def closure = { }
                    if (true) { }
                    while(ready) { }
                    try {
                    } catch(Exception e) {
                    } finally { }
                    for(int i=0; i<10; i++) { }
                    for(String name in names) { }
                    for(String name: names) { }
                    if (count > this."maxPriority${priority}Violations") { }
                    while (count > this."maxPriority${priority}Violations") { }
                }
                MyClass() {
                    this(classNames)
                } // ok
                static void reset() { violationCounts = [1:0, 2:0, 3:0] }
                void doStuff() { println 9 }
            }
            interface MyInterface { }
            enum MyEnum { OK, BAD }
        ' contains a GString-type expression: '${priority}Violations") { }'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=304 Msg=[The String '
            def foo = 1
            "I am a ${ -> foo }"
        ' contains a GString-type expression: '${ -> foo }'] Src=[assertNoViolations(''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=312 Msg=[The String '
            def foo = 1
            "I am a ${ -> foo }0"
        ' contains a GString-type expression: '${ -> foo }'] Src=[assertNoViolations(''']

File: formatting/SpaceAfterCommaRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=53 Msg=[The String '
            class MyClass {
                def template() {
                    return {
                        td(getResourceBundleString('htmlReport.summary.allPackages'), class:'allPackages')
                        td {
                            a(pathName, href:"#${pathName}")
                        }
                    }
                }
            }
        ' contains a GString-type expression: '${pathName}'] Src=[final SOURCE = ''']

File: formatting/SpaceAfterOpeningBraceRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=40 Msg=[The String '
            class MyClass {
                def myMethod() {
                    def closure = { }
                    if (true) { }
                    while(ready) { }
                    try {
                    } catch(Exception e) {
                    } finally { }
                    for(int i=0; i<10; i++) { }
                    for(String name in names) { }
                    for(String name: names) { }
                    if (count > this."maxPriority${priority}Violations") { }
                    while (count > this."maxPriority${priority}Violations") { }
                }
                MyClass() {
                    this(classNames)
                }
                MyClass(String s) { }
                MyClass(@Annotation('${prop}') String s) {
                }
                MyClass(Date date) { // comment
                    this(classNames)
                }
                MyClass(Object object) { /* comment */ }
            }
            interface MyInterface { }
            enum MyEnum { OK, BAD }
            trait MyTrait { }
        ' contains a GString-type expression: '${priority}Violations") { }'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=87 Msg=[The String '
            class MyClass {
                def myMethod() {
                    def closure = {}
                    if (true) {}
                    while(ready) {}
                    try {
                    } catch(Exception e) {
                    } finally {}
                    for(int i=0; i<10; i++) {}
                    for(String name in names) {}
                    for(String name: names) {}
                    if (count > this."maxPriority${priority}Violations") {}
                    while (count > this."maxPriority${priority}Violations") {}
                }
                void doStuff2() {}
                MyClass() {}
                MyClass(@Annotation('${prop}') String s) {}
            }
            interface MyInterface2 {}
        ' contains a GString-type expression: '${priority}Violations") {}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=181 Msg=[The String '
            class MyClass {
                MyClass() {int count }
                MyClass() {s = '{"json": true}' }
                MyClass(@Annotation('${prop}') String s) {println 123 }

            }
        ' contains a GString-type expression: '${prop}') String s) {println 123 }'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=192 Msg=[The String 'MyClass(@Annotation('${prop}') String s) {println 123 }' contains a GString-type expression: '${prop}') String s) {println 123 }'] Src=[[line:5, source:'MyClass(@Annotation(\'${prop}\') String s) {println 123 }', message:'The opening brace for the method <init> in class MyClass'])]
    Violation: Rule=GStringExpressionWithinString P=2 Line=310 Msg=[The String '
            class MyClass {
                String s
                MyClass() { s = '{"json": true}' }
                MyClass(@Annotation('${prop}') String s) { println 123 }
            }
        ' contains a GString-type expression: '${prop}') String s) { println 123 }'] Src=[final SOURCE = ''']

File: formatting/SpaceAroundMapEntryColonRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=167 Msg=[The return keyword is not needed and can be removed] Src=[return inlineViolation("The colon for the literal Map entry for key [$keyName] within class $className" +]

File: formatting/SpaceBeforeClosingBraceRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=39 Msg=[The String '
            class MyClass {
                def myMethod() {
                    def closure = { }
                    if (true) { }
                    while(ready) { }
                    try {
                    } catch(Exception e) {
                    } finally { }
                    for(int i=0; i<10; i++) { }
                    for(String name in names) { }
                    for(String name: names) { }
                    if (count > this."maxPriority${priority}Violations") { }
                    while (count > this."maxPriority${priority}Violations") { }
                }
                MyClass() {
                    this(classNames)
                }
                static void reset() { violationCounts = [1:0, 2:0, 3:0] }
                void doStuff() { println 9 }
            }
            interface MyInterface { }
            enum MyEnum { OK, BAD }
        ' contains a GString-type expression: '${priority}Violations") { }'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=80 Msg=[The String '
            class MyClass {
                def myMethod() {
                    def closure = {}
                    if (true) {}
                    while(ready) {}
                    try {
                    } catch(Exception e) {
                    } finally {}
                    for(int i=0; i<10; i++) {}
                    for(String name in names) {}
                    for(String name: names) {}
                    if (count > this."maxPriority${priority}Violations") {}
                    while (count > this."maxPriority${priority}Violations") {}
                }
                void doStuff2() {}
            }
            interface MyInterface2 {}
        ' contains a GString-type expression: '${priority}Violations") {}'] Src=[final SOURCE = ''']

File: formatting/SpaceBeforeOpeningBraceRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=38 Msg=[The String '
            class MyClass {
                def myMethod() {
                    def closure = { }
                    if (true) { }
                    while(ready) { }
                    try {
                    } catch(Exception e) {
                    } finally { }
                    for(int i=0; i<10; i++) { }
                    for(String name in names) { }
                    for(String name: names) { }
                    if (count > this."maxPriority${priority}Violations") { }
                    while (count > this."maxPriority${priority}Violations") { }
                }
                MyClass() {
                    this(classNames)
                }
            }
            interface MyInterface { }
            enum MyEnum { OK, BAD }
            trait MyTrait { }
        ' contains a GString-type expression: '${priority}Violations") { }'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=262 Msg=[The String '
            def foo = 1
            "I am a ${ -> foo }"
        ' contains a GString-type expression: '${ -> foo }'] Src=[assertNoViolations(''']

File: generic/IllegalPackageReferenceRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=64 Msg=[The String '
            if (value.class == org.bad.BadClass) { }
            println "isClosure=${value instanceof org.bad.OtherClass}"
            def count = org.bad.Helper.getCount()
        ' contains a GString-type expression: '${value instanceof org.bad.OtherClass}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=72 Msg=[The String 'println "isClosure=${value instanceof org.bad.OtherClass}"' contains a GString-type expression: '${value instanceof org.bad.OtherClass}'] Src=[[line:3, source:'println "isClosure=${value instanceof org.bad.OtherClass}"', message:'org.bad'],]

File: generic/StatelessClassRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=84 Msg=[The String '
          class MyClass {
            @Value('${org.codenarc.test}')
            BigDecimal depositAmount
          }
        ' contains a GString-type expression: '${org.codenarc.test}'] Src=[final SOURCE = ''']

File: grails/GrailsMassAssignmentRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=36 Msg=[The String '
            class Person {
                String name
                Boolean isAdmin
            }
            def bindingMap = [name: 'John', isAdmin: true]
            def person = new Person()
            def p2 = new Person("It is currently ${ new Date() }")
            def p3 = new Person(bindingMap)
            person.name = bindingMap['name']
            person.isAdmin = bindingMap.isAdmin
            person.properties = "It is currently ${ new Date() }"
        ' contains a GString-type expression: '${ new Date() }'] Src=[final SOURCE = ''']

File: grails/GrailsServletContextReferenceRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=78 Msg=[The String '
            class MyClass {
                def mySession = servletContext

                def edit = {
                    println "amount=${servletContext.amount}"
                }
            }
        ' contains a GString-type expression: '${servletContext.amount}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=87 Msg=[The String 'println "amount=${servletContext.amount}"' contains a GString-type expression: '${servletContext.amount}'] Src=[assertTwoViolations(SOURCE, 3, 'def mySession = servletContext', 6, 'println "amount=${servletContext.amount}"')]

File: groovyism/ClosureAsLastMethodParameterRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=248 Msg=[The String '
            new Exception("${it.orElseThrow { new AssertionError() }}")
        ' contains a GString-type expression: '${it.orElseThrow { new AssertionError() }}'] Src=[final SOURCE = ''']

File: groovyism/GStringAsMapKeyRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=44 Msg=[The String '
            Map map = ["${ someRef }" : 'invalid' ]
        ' contains a GString-type expression: '${ someRef }'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=48 Msg=[The String '["${ someRef }" :' contains a GString-type expression: '${ someRef }'] Src=[2, '["${ someRef }" :')]

File: groovyism/GStringExpressionWithinStringRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=49 Msg=[The String '
            class SomeClass {
                @SomeAnnotationOnField('${sample.property1}')
                String sampleProperty

                @SomeAnnotationOnMethod('${sample.property2}')
                void method() {
                }
            }
        ' contains a GString-type expression: '${sample.property1}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=64 Msg=[The String '
            @SomeAnnotationOnClass('${sample.property1}')
            class SomeClass {
                @SomeAnnotationOnField('${sample.property2}')
                String sampleProperty

                @SomeAnnotationOnMethod('${sample.property3}')
                void method() {
                }
            }
        ' contains a GString-type expression: '${sample.property1}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=80 Msg=[The String '
            @SomeAnnotationOnClass(attribute='${sample.property1}',
                            nested=[@NestedAnnotation('${sample.property2}'),
                                    @NestedAnnotation('${sample.property3}')],
                             someOtherAttribute='${sample.property4}')
            class SomeClass {
            }
        ' contains a GString-type expression: '${sample.property1}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=93 Msg=[The String '
            @SomeAnnotationOnClass(attribute=['${sample.property1}', '${sample.property2}'])
            class SomeClass {
            }
        ' contains a GString-type expression: '${sample.property1}', '${sample.property2}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=103 Msg=[The String '
            def valueToBeReplaced = '123'
            def str1 = "123"
            def str2 = "abc def ghi"
            def str3 = "abc ${count}"
            def str4 = "abc $count    }"
            def str5 = "abc {123}"
            def str6 = "abc ${}"
            def str7 = "total: ${count * 25}"
            def str8 = "$valueToBeReplaced $valueNotToBeReplaced"
        ' contains a GString-type expression: '${count}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=119 Msg=[The String '
            def "plugin does not apply idea plugin"() {
                given:
                buildScript << """
                    task $testTaskName {
                        doLast {
                            println "Has idea plugin: \${project.plugins.hasPlugin(IdeaPlugin)}"
                        }
                    }
                """

                expect:
                runTask(testTaskName).output.contains('Has idea plugin: false')

                where:
                testTaskName = 'hasIdeaPlugin'
            }
            ' contains a GString-type expression: '${project.plugins.hasPlugin(IdeaPlugin)}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=142 Msg=[The String '
            def str1 = 'total: ${count}'
            def str2 = 'average: ${total / count}'
        ' contains a GString-type expression: '${count}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=147 Msg=[The String 'def str1 = 'total: ${count}'' contains a GString-type expression: '${count}'] Src=[[line:2, source:"def str1 = 'total: \${count}'", message:'\'${count}\''],]
    Violation: Rule=GStringExpressionWithinString P=2 Line=147 Msg=[The String ''${count}'' contains a GString-type expression: '${count}'] Src=[[line:2, source:"def str1 = 'total: \${count}'", message:'\'${count}\''],]
    Violation: Rule=GStringExpressionWithinString P=2 Line=148 Msg=[The String 'def str2 = 'average: ${total / count}'' contains a GString-type expression: '${total / count}'] Src=[[line:3, source:"def str2 = 'average: \${total / count}'", message:'\'${total / count}\''])]
    Violation: Rule=GStringExpressionWithinString P=2 Line=148 Msg=[The String ''${total / count}'' contains a GString-type expression: '${total / count}'] Src=[[line:3, source:"def str2 = 'average: \${total / count}'", message:'\'${total / count}\''])]
    Violation: Rule=GStringExpressionWithinString P=2 Line=153 Msg=[The String '
            class SomeClass {
                @SomeAnnotationOnMethod('${sample.property}')
                void method() {
                    def str1 = 'total: ${count}'
                }
            }
        ' contains a GString-type expression: '${sample.property}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=161 Msg=[The String 'def str1 = 'total: ${count}'' contains a GString-type expression: '${count}'] Src=[assertSingleViolation(SOURCE, 5, "def str1 = 'total: \${count}'", '\'${count}\'')]
    Violation: Rule=GStringExpressionWithinString P=2 Line=161 Msg=[The String ''${count}'' contains a GString-type expression: '${count}'] Src=[assertSingleViolation(SOURCE, 5, "def str1 = 'total: \${count}'", '\'${count}\'')]

File: imports/UnusedImportRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=194 Msg=[The String '
            import test.TestData1
            import test.TestData2
            import test.TestData3
            import test.TestData4
            import test.TestData5
            import test.TestData6
            import test.TestData7
            import test.TestData8
            import test.TestData9
            import test.TestData10
            import test.TestData11
            import test.TestData12
            import test.TestData13
            import test.TestData14
            import test.TestData15

            def GSTRING1 = " ${TestData1.GOOD_XML}"
            def GSTRING2 = " $TestData2.XML"
            def MAP1 = [(TestData3):123]
            def MAP2 = [abc:TestData4]
            def MAP3 = [abc:TestData5, ddd:123]
            def LIST = [TestData6,TestData7]
            def OPERATORS1 = 0+TestData8.VALUE-TestData9.VALUE
            def OPERATORS2 = 9*TestData10.VALUE/TestData11.VALUE
            def OPERATORS3 = 64&TestData12.VALUE|TestData13.VALUE^TestData14.VALUE
            def OPERATORS4 = !TestData15.VALUE
        ' contains a GString-type expression: '${TestData1.GOOD_XML}'] Src=[final SOURCE = ''']

File: naming/FieldNameRuleTest.groovy
    Violation: Rule=MethodCount P=2 Line=28 Msg=[Class org.codenarc.rule.naming.FieldNameRuleTest has 32 methods] Src=[class FieldNameRuleTest extends AbstractRuleTestCase<FieldNameRule> {]

File: size/GMetricsSourceCodeAdapterTest.groovy
    Violation: Rule=MisorderedStaticImports P=3 Line=22 Msg=[Static imports should appear before normal imports] Src=[import static org.codenarc.test.TestUtil.shouldFailWithMessageContaining]

File: size/ParameterCountRuleTest.groovy
    Violation: Rule=UnnecessaryReturnKeyword P=3 Line=252 Msg=[The return keyword is not needed and can be removed] Src=[return inlineViolation("Number of parameters in ${name} exceeds maximum allowed (${rule.maxParameters}).")]

File: unnecessary/ConsecutiveStringConcatenationRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=65 Msg=[The String '
            def b = "$Hello" + 'World'  // should be "${Hello}World"
        ' contains a GString-type expression: '${Hello}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=73 Msg=[The String '
            def c = 'Hello' + "$World"  // should be "Hello${World}"
        ' contains a GString-type expression: '${World}'] Src=[final SOURCE = ''']

File: unnecessary/UnnecessaryGStringRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=36 Msg=[The String '
            def docFile = "docs/codenarc-rules-${ruleSetName}.apt"
        ' contains a GString-type expression: '${ruleSetName}'] Src=[final SOURCE = ''']

File: unnecessary/UnnecessaryGetterRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=180 Msg=[The String '
            Mock {
                getSomeData()
            }
            Stub(1,2,3) {
                getData2()
            }
            "${'Stub'}"(MyClass) {
                getData3()
            }
            def closure = { getData4() }
            Mock({ getData5() }, 1234)      // 2nd param is not a Closure
            Spy {
                getMoreData()
            }
        ' contains a GString-type expression: '${'Stub'}'] Src=[final SOURCE = ''']

File: unnecessary/UnnecessaryPackageReferenceRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=66 Msg=[The String '
            if (value.class == java.math.BigDecimal) { }
            println "isClosure=${value instanceof groovy.lang.Closure}"
            def processors = java.lang.Runtime.availableProcessors()
        ' contains a GString-type expression: '${value instanceof groovy.lang.Closure}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=73 Msg=[The String 'println "isClosure=${value instanceof groovy.lang.Closure}"' contains a GString-type expression: '${value instanceof groovy.lang.Closure}'] Src=[[line:3, source:'println "isClosure=${value instanceof groovy.lang.Closure}"', message:'groovy.lang'],]

File: unnecessary/UnnecessarySetterRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=69 Msg=[The String '
            if (!file.setExecutable(true)) {
                throw new Exception("Cannot set ${file} as executable")
            }
            def count = x.setCount(92)
        ' contains a GString-type expression: '${file}'] Src=[final SOURCE = ''']

File: unnecessary/UnnecessaryToStringRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=67 Msg=[The String '
            class MyClass {
                def name = "Joe" + new Date().toString()

                void run() {
                    Object object = 1
                    def string = 'some string' + object.toString()
                    def withinGString = "processing: ${'prefix' + object.toString()}"

                    def bigString = 'some string' + new Date() + object.toString()      // not a violation; known limitation
                    def other = 123 + object.toString().toInteger()     // not a violation
                }
            }
        ' contains a GString-type expression: '${'prefix' + object.toString()}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=84 Msg=[The String 'def withinGString = "processing: ${'prefix' + object.toString()}"' contains a GString-type expression: '${'prefix' + object.toString()}'] Src=[[line:8, source:'def withinGString = "processing: ${\'prefix\' + object.toString()}"', message:'Calling toString() on [object] in class MyClass is unnecessary'])]
    Violation: Rule=GStringExpressionWithinString P=2 Line=89 Msg=[The String '
            def string = "some string${123L.toString()} or ${123} or ${'ABC'} or ${new Date().toString()}"
            def string2 = """
                 processing: ${123L.toString()}
                 processing: ${new Date().toString()}
                """
        ' contains a GString-type expression: '${123L.toString()} or ${123} or ${'ABC'} or ${new Date().toString()}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=97 Msg=[The String 'def string = "some string${123L.toString()} or ${123} or ${'ABC'} or ${new Date().toString()}"' contains a GString-type expression: '${123L.toString()} or ${123} or ${'ABC'} or ${new Date().toString()}'] Src=[[line:2, source:'def string = "some string${123L.toString()} or ${123} or ${\'ABC\'} or ${new Date().toString()}"', message:'Calling toString() on [123] in class None is unnecessary'],]
    Violation: Rule=GStringExpressionWithinString P=2 Line=98 Msg=[The String 'def string = "some string${123L.toString()} or ${123} or ${'ABC'} or ${new Date().toString()}"' contains a GString-type expression: '${123L.toString()} or ${123} or ${'ABC'} or ${new Date().toString()}'] Src=[[line:2, source:'def string = "some string${123L.toString()} or ${123} or ${\'ABC\'} or ${new Date().toString()}"', message:'Calling toString() on [new Date()] in class None is unnecessary'],]
    Violation: Rule=GStringExpressionWithinString P=2 Line=99 Msg=[The String 'processing: ${123L.toString()}' contains a GString-type expression: '${123L.toString()}'] Src=[[line:4, source:'processing: ${123L.toString()}', message:'Calling toString() on [123] in class None is unnecessary'],]
    Violation: Rule=GStringExpressionWithinString P=2 Line=100 Msg=[The String 'processing: ${new Date().toString()}' contains a GString-type expression: '${new Date().toString()}'] Src=[[line:5, source:'processing: ${new Date().toString()}', message:'Calling toString() on [new Date()] in class None is unnecessary']]

File: unused/AbstractUnusedPrivateFieldRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=160 Msg=[The String '
            class MyClass {
                private int count
                def other = this."${'count'}"
            }
        ' contains a GString-type expression: '${'count'}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=171 Msg=[The String '
            class MyClass {
                private int count
                def varName = "count"
                def other = this."${varName}"     // can't see this
            }
        ' contains a GString-type expression: '${varName}'] Src=[final SOURCE = ''']

File: unused/UnusedMethodParameterRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=150 Msg=[The String '
            class MyClass {
                MyClass() { }
                MyClass(String id) { println id }

                String myMethod1(String id, int value) { doSomething(value); return id }
                void myMethod2(int value) { def x = value }
                def myMethod3(Date startDate) { return "${startDate}" }
                def myMethod4(Date startDate) {
                    return new Object() {
                        def x = startDate
                    }
                }
                def myMethod5(Date startDate) {
                    return new Object() {
                        String toString() { return startDate }
                    }
                }
            }
        ' contains a GString-type expression: '${startDate}" }'] Src=[final SOURCE = ''']

File: unused/UnusedPrivateMethodParameterRuleTest.groovy
    Violation: Rule=GStringExpressionWithinString P=2 Line=126 Msg=[The String '
            class MyClass {
                private String myMethod1(String id, int value) { doSomething(value); return id }
                private void myMethod2(int value) { def x = value }
                private def myMethod3(Date startDate) { return "${startDate}" }
                private def myMethod4(Date startDate) {
                    return new Object() {
                        def x = startDate
                    }
                }
                private def myMethod5(Date startDate) {
                    return new Object() {
                        String toString() { return startDate }
                    }
                }
            }
        ' contains a GString-type expression: '${startDate}" }'] Src=[final SOURCE = ''']

File: unused/UnusedPrivateMethodRuleTest.groovy
    Violation: Rule=MethodCount P=2 Line=26 Msg=[Class org.codenarc.rule.unused.UnusedPrivateMethodRuleTest has 37 methods] Src=[class UnusedPrivateMethodRuleTest extends AbstractRuleTestCase<UnusedPrivateMethodRule> {]
    Violation: Rule=GStringExpressionWithinString P=2 Line=354 Msg=[The String '
            class MyClass {
                private int countStuff() { return 99 }
                int somePublicMethod() { }
                def abc = 'abc'
                private String getName() { 'abc' }
                private getPrice() { 0.0 }

                def doStuff() {
                    def count = countStuff()
                    def newName = this.getName()
                }

                def myClosure = { println "price is ${getPrice()}" }
            }
        ' contains a GString-type expression: '${getPrice()}" }'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=423 Msg=[The String '
            class MyClass {
                static int getTotal() {
                    println "total=${MyClass.countStuff()}"
                }
                private static int countStuff() { }
            }
        ' contains a GString-type expression: '${MyClass.countStuff()}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=436 Msg=[The String '
            class MyClass {
                private int countStuff() { }
                def other = this."${countStuff}"()
            }
        ' contains a GString-type expression: '${countStuff}'] Src=[final SOURCE = ''']
    Violation: Rule=GStringExpressionWithinString P=2 Line=458 Msg=[The String '
            class MyClass {
                private int countStuff() { }
                def varName = "countStuff"
                def other = this."${varName}"()     // can't see this
            }
        ' contains a GString-type expression: '${varName}'] Src=[final SOURCE = ''']

File: unused/UnusedVariableRuleTest.groovy
    Violation: Rule=MethodCount P=2 Line=26 Msg=[Class org.codenarc.rule.unused.UnusedVariableRuleTest has 35 methods] Src=[class UnusedVariableRuleTest extends AbstractRuleTestCase<UnusedVariableRule> {]

[CodeNarc (https://www.codenarc.org) v2.2.0]
